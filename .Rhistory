sample_mean <- function(x){
weighted.mean(x, w = df$p)
}
df$rank_x1 <- rep(c(1,2,3),2)
df$rank_x2 <-  rep(c(1,2),each = 3)
sample_list <- list(x1_mean = df$x_1, x2_mean = df$x_2, rank_x1_mean = rep(c(1,2,3),2), rank_x2_mean = rep(c(1,2),each = 3))
means <- lapply(sample_list, sample_mean)
rank_df <- (df %>% mutate(
x1_star = x_1 - means[[1]],
x2_star = x_2 - means[[2]],
r1_star = rank_x1 - means[[3]],
r2_star = rank_x2 - means[[4]],
x_cov = x1_star * x2_star,
r_cov = r1_star * r2_star
) %>%
select(x_1, x_2, x_cov, r_cov, p))
rank_df
knitr::kable(rank_df)
sample_mean <- function(x){
weighted.mean(x, w = df$p)
}
df$rank_x1 <- rep(c(1,2,3),2)
df$rank_x2 <-  rep(c(1,2),each = 3)
sample_list <- list(x1_mean = df$x_1, x2_mean = df$x_2, rank_x1_mean = rep(c(1,2,3),2), rank_x2_mean = rep(c(1,2),each = 3))
means <- lapply(sample_list, sample_mean)
rank_df <- df %>% mutate(
x1_star = x_1 - means[[1]],
x2_star = x_2 - means[[2]],
r1_star = rank_x1 - means[[3]],
r2_star = rank_x2 - means[[4]],
x_cov = x1_star * x2_star,
r_cov = r1_star * r2_star
) %>%
select(x_1, x_2, x_cov, r_cov, p)
knitr::kable(rank_df)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
library(tidyverse)
x1 <- 1:80
x2 <- c(80:70,11:69,10:1)
cor(x1, x2, method = "spearman")
cor(x1, x2, method = "kendall")
plot(x1,x2)
dim(c(1,2))
length(c(1,2))
?sample_n
?tbl_df
which(c(F,T))
source('~/Desktop/projects/Github/Simulacra/build_site.R', echo=TRUE)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_smooth(aes(x = mc), col = "blue") +
geom_smooth(aes(y = s_dis), col = "red")
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue") +
geom_freqpoly(aes(y = s_dis), col = "red")
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue") +
geom_freqpoly(aes(x = s_dis), col = "red")
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue", alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "markov_chain", alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "stationary", alpha = .5) +
scale_colour_manual(name="Line Color",
values=c(arkov_chain="red", stationary="blue")
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "markov_chain", alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "stationary", alpha = .5) +
scale_colour_manual(name="Line Color",
values=c(arkov_chain="red", stationary="blue"))
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc, col = mc),  alpha = .5) +
geom_freqpoly(aes(x = s_dis, col = s_dis), alpha = .5)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc, col = mc),  alpha = .5) +
geom_freqpoly(aes(x = s_dis, col = s_dis), alpha = .5) +
scale_color_brewer()
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc, col = mc),  alpha = .5) +
geom_freqpoly(aes(x = s_dis, col = s_dis), alpha = .5) +
scale_color_manual()
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc, col = mc),  alpha = .5) +
geom_freqpoly(aes(x = s_dis, col = s_dis), alpha = .5) +
guides(fill = TRUE)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
t <- 10^5
rho <- 1.1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5) +
t <- 10^5
rho <- 1.1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[1,10^5/2],
tail = markov_chain[10^5/2+1,10^5])
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[1:10^5/2],
tail = markov_chain[10^5/2+1:10^5])
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[1:10^5/2],
tail = markov_chain[(10^5/2+1):10^5])
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[2:10^5/2],
tail = markov_chain[(10^5/2+1):10^5])
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[1:(10^5/2)],
tail = markov_chain[(10^5/2+1):10^5])
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = head), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = tail), col = "orange", alpha = .5)
t <- 10^5
rho <- .9
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
stationary_distribution <-  rnorm(n = t, mean = 0, sd = sqrt(1/(1-rho^2)))
mc_frame <- data.frame(mc = markov_chain,
s_dis = stationary_distribution)
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = mc), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = s_dis), col = "orange", alpha = .5)
g47=rgamma(5000,4,7)
u=runif(5000,max=dgamma(g47,4,7))
x=g47[u<dgamma(g47,4.3,6.2)]
par(mfrow=c(1,3),mar=c(4,4,1,1))
hist(x,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Accept-Reject with Ga(4.7) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(x)/5000
X=rep(0,5000)
X[1]=rgamma(1,4.3,6.2)
for (t in 2:5000){
rho=(dgamma(X[t-1],4,7)*dgamma(g47[t],4.3,6.2))/
(dgamma(g47[t],4,7)*dgamma(X[t-1],4.3,6.2))
X[t]=X[t-1]+(g47[t]-X[t-1])*(runif(1)<rho)
}
hist(X,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Metropolis-Hastings with Ga(4,7) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(unique(X))/5000
g56=rgamma(5000,5,6)
X[1]=rgamma(1,4.3,6.2)
for (t in 2:5000){
rho=(dgamma(X[t-1],5,6)*dgamma(g56[t],4.3,6.2))/
(dgamma(g56[t],5,6)*dgamma(X[t-1],4.3,6.2))
X[t]=X[t-1]+(g56[t]-X[t-1])*(runif(1)<rho)
}
hist(X,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Metropolis-Hastings with Ga(5,6) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(unique(X))/5000
g47=rgamma(5000,4,7)
u=runif(5000,max=dgamma(g47,4,7))
x=g47[u<dgamma(g47,4.3,6.2)]
par(mfrow=c(1,3),mar=c(4,4,1,1))
hist(x,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Accept-Rej with Ga(4.7) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(x)/5000
X=rep(0,5000)
X[1]=rgamma(1,4.3,6.2)
for (t in 2:5000){
rho=(dgamma(X[t-1],4,7)*dgamma(g47[t],4.3,6.2))/
(dgamma(g47[t],4,7)*dgamma(X[t-1],4.3,6.2))
X[t]=X[t-1]+(g47[t]-X[t-1])*(runif(1)<rho)
}
hist(X,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Met-Hast with Ga(4,7) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(unique(X))/5000
g56=rgamma(5000,5,6)
X[1]=rgamma(1,4.3,6.2)
for (t in 2:5000){
rho=(dgamma(X[t-1],5,6)*dgamma(g56[t],4.3,6.2))/
(dgamma(g56[t],5,6)*dgamma(X[t-1],4.3,6.2))
X[t]=X[t-1]+(g56[t]-X[t-1])*(runif(1)<rho)
}
hist(X,freq=FALSE,xlab="",ylab="",col="wheat2",
main="Met-Hast with Ga(5,6) proposal")
curve(dgamma(x,4.3,6.2),lwd=2,col="sienna",add=T)
length(unique(X))/5000
t <- 10^5
rho <- 1
markov_chain <- numeric(t)
markov_chain[1] = rnorm(1)
for(i in 2:t){
markov_chain[i] <- rnorm(n = 1, mean = markov_chain[i-1] * rho, sd = 1 )
}
mc_frame <- data.frame(head = markov_chain[1:(10^5/2)],
tail = markov_chain[(10^5/2+1):10^5])
ggplot(data = mc_frame) +
geom_freqpoly(aes(x = head), col = "blue",  alpha = .5) +
geom_freqpoly(aes(x = tail), col = "orange", alpha = .5)
na.omit(c(NA,NA,3
))
na.omit(c(NA,NA,3))
na.omit(NA)
a <- na.omit(NA)
attr(a)
a
class(a)
a
a
a
attributes(a)
a$na.action
class(a)
attributes(a)$na.action
attr(a,na.action)
attr(a,"na.action")
attr(a,"na.action") == "omit"
na.omit(c(NA,NA,3))
na.omit(c(NA,NA,6))
attr(na.omit(c(NA,NA,6)),"na.action")
letters[attr(na.omit(c(NA,NA,6)),"na.action")]
knitr::opts_chunk$set(cache = TRUE)
library(ISLR)
library(tidyverse)
library(glmnet)
library(magrittr)
library(caret)
caret_RMSE <- function(x){sqrt(sum((x-Y.test)^2))/length(x)}
trainControl <- trainControl(method="cv", number=5)
my_caret <- function(method_name){
#this function accepts the name of the method and returns its RMSE from testing it on our specified College dataset
method_fit <- train(Apps~., data=data_df, method=method_name, metric="RMSE", preProc=c("center","scale"), trControl=trainControl)
method_predictions <- predict(method_fit, X.test)
method_RMSE <- caret_RMSE(method_predictions)
list(method_name, method_RMSE)
}
caret_names <- list("lm", "lasso", "ridge", "glmnet", "pcr", "pls", "lars")
map(caret_names, my_caret) %>%
transpose() %>%
map(unlist) %>%
set_names(c("models","RMSE")) %>%
as_tibble() %>%
arrange(RMSE)->
caret_table
knitr::opts_chunk$set(cache = TRUE)
library(ISLR)
library(tidyverse)
library(glmnet)
library(magrittr)
str(College)
X = model.matrix(Apps ~ ., data = College)
Y = College$Apps
data_df <- cbind(as.data.frame(X), College[, "Apps"]) %>% rename(Apps = `College[, "Apps"]`)
train <- sample(1:nrow(X), replace = FALSE, round(nrow(X) * .25))
X.train <- X[train, ]
Y.train <- Y[train]
X.test <- X[-train, ]
Y.test <- Y[-train]
OLS.mod <- glmnet(X.train, Y.train)
OLS.pred <- predict(OLS.mod, newx = X.test)
RMSE <- function(x){sqrt(sum((x-Y.test)^2))/length(x)}
Percent.Error <- function(x){RMSE(x)/mean(Y) * 100}
OLS.RMSE <- RMSE(OLS.pred)
OLS.Percent.Err <- Percent.Error(OLS.pred)
results <- tibble(model = "OLS",
RMSE = OLS.RMSE,
)
knitr::kable(results, digits = 3)
grid <- 10^ seq (10,-2, length =100)
ridge.mod <- glmnet(X.test, Y.test, alpha = 0, lambda = grid)
# alpha = 0 specifies that we are using a Ridge Regression.
# glmnet automatically does centering first; Standardize = TRUE by default
dim(coef(ridge.mod))
el2norm <- function(x){sqrt(sum(x^2))}
el2norm.r <- function(col){el2norm(coef(ridge.mod)[, col])}
coef(ridge.mod)[,c(10,50,90)] %>% rbind( map_dbl(c(10,50,90), el2norm.r) ) %>% rbind(ridge.mod$lambda[c(10,50,90)])
predict(ridge.mod, s=80, type="coefficients")
# print(ridge.mod)   output is too long
set.seed(10)
ridge.cv <- cv.glmnet(X.train, Y.train, alpha = 0)
ridge.pred <- predict(ridge.cv, s="lambda.min", newx = X.test)
ridge.RMSE <- RMSE(ridge.pred)
bestlam <- ridge.cv$lambda.min
set.seed(1)
lasso.cv <- cv.glmnet(X.train, Y.train, alpha = 1)
lasso.lam <- lasso.cv$lambda.min
coef(lasso.cv, s = "lambda.min")
lasso.mod <- glmnet(X.train, Y.train, alpha = 1, lambda = grid)
lasso.pred <- predict(lasso.mod, s=lasso.lam, newx = X.test)
lasso.RMSE <- RMSE(lasso.pred)
results <- rbind(results, list("Ridge", ridge.RMSE), list("Lasso", lasso.RMSE))
knitr::kable(results, digits = 3)
library(pls)
set.seed(2)
PCR.mod <- pcr(Apps ~ ., subset = train, data = data_df,  validation = "CV")
validationplot(PCR.mod, val.type = "MSEP")
summary(PCR.mod)
PCR.pred <- predict(PCR.mod, X.test, ncomp = 3)
PCR.RMSE <- RMSE(PCR.pred)
results <- rbind(results,  list("PCR", PCR.RMSE))
knitr::kable(results, digits = 3)
PLS.mod <- plsr(Apps ~ ., data = data_df, subset = train, validation = "CV")
summary(PLS.mod)
validationplot(PLS.mod)
PLS.pred <- predict(PLS.mod, X.test, ncomp = 3)
PLS.RMSE <- RMSE(PLS.pred)
results <- rbind(results, list("PLS", PLS.RMSE))
knitr::kable(results, digits = 3)
library(caret)
caret_RMSE <- function(x){sqrt(sum((x-Y.test)^2))/length(x)}
trainControl <- trainControl(method="cv", number=5)
my_caret <- function(method_name){
#this function accepts the name of the method and returns its RMSE from testing it on our specified College dataset
method_fit <- train(Apps~., data=data_df, method=method_name, metric="RMSE", preProc=c("center","scale"), trControl=trainControl)
method_predictions <- predict(method_fit, X.test)
method_RMSE <- caret_RMSE(method_predictions)
list(method_name, method_RMSE)
}
caret_names <- list("lm", "lasso", "ridge", "glmnet", "pcr", "pls", "lars")
map(caret_names, my_caret) %>%
transpose() %>%
map(unlist) %>%
set_names(c("models","RMSE")) %>%
as_tibble() %>%
arrange(RMSE)->
caret_table
knitr::kable(caret_table, digits = 3, booktabs = TRUE, caption = "Result produced by Caret. Models arranged by RMSE.")
